
name: Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'auto'
        type: choice
        options:
        - auto
        - patch
        - minor
        - major
      skip_tests:
        description: 'Skip tests (use with caution)'
        required: false
        default: false
        type: boolean

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Run tests
        if: ${{ !inputs.skip_tests }}
        run: npx vitest run

      - name: Build project
        run: npm run build

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Determine version bump type
        id: version-type
        run: |
          if [ "${{ inputs.version_type }}" = "auto" ]; then
            # Get commits since last tag
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$LAST_TAG" ]; then
              COMMITS=$(git log --pretty=format:"%s" HEAD)
            else
              COMMITS=$(git log --pretty=format:"%s" ${LAST_TAG}..HEAD)
            fi
            
            # Determine version bump based on conventional commits
            if echo "$COMMITS" | grep -q "BREAKING CHANGE\|!:"; then
              VERSION_TYPE="major"
            elif echo "$COMMITS" | grep -q "^feat"; then
              VERSION_TYPE="minor"
            elif echo "$COMMITS" | grep -q "^fix"; then
              VERSION_TYPE="patch"
            else
              VERSION_TYPE="patch"
            fi
          else
            VERSION_TYPE="${{ inputs.version_type }}"
          fi
          
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "Determined version bump type: $VERSION_TYPE"

      - name: Bump version
        id: version
        run: |
          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"
          
          # Calculate new version based on bump type
          BUMP_TYPE="${{ steps.version-type.outputs.version_type }}"
          
          if [ "$BUMP_TYPE" = "major" ]; then
            NEW_VERSION=$(node -p "
              const [major, minor, patch] = '$CURRENT_VERSION'.split('.').map(Number);
              \`\${major + 1}.0.0\`
            ")
          elif [ "$BUMP_TYPE" = "minor" ]; then
            NEW_VERSION=$(node -p "
              const [major, minor, patch] = '$CURRENT_VERSION'.split('.').map(Number);
              \`\${major}.\${minor + 1}.0\`
            ")
          else
            NEW_VERSION=$(node -p "
              const [major, minor, patch] = '$CURRENT_VERSION'.split('.').map(Number);
              \`\${major}.\${minor}.\${patch + 1}\`
            ")
          fi
          
          echo "New version: $NEW_VERSION"
          
          # Update version.json
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%S.%03dZ")
          GIT_HASH=$(git rev-parse --short HEAD)
          BUILD_NUMBER=$(($(cat public/version.json | grep -o '"buildNumber": [0-9]*' | grep -o '[0-9]*') + 1))
          
          cat > public/version.json << EOF
          {
            "version": "$NEW_VERSION",
            "buildDate": "$BUILD_DATE",
            "gitHash": "$GIT_HASH",
            "buildNumber": $BUILD_NUMBER,
            "environment": "production"
          }
          EOF
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "git_hash=$GIT_HASH" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Get commits since last tag for changelog
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%h %s" HEAD --reverse)
          else
            COMMITS=$(git log --pretty=format:"%h %s" ${LAST_TAG}..HEAD --reverse)
          fi
          
          # Generate changelog sections
          FEATURES=""
          FIXES=""
          BREAKING=""
          OTHER=""
          
          while IFS= read -r commit; do
            if [[ $commit =~ ^[a-f0-9]+\ feat(\(.+\))?!?: ]]; then
              if [[ $commit =~ ! ]]; then
                BREAKING="$BREAKING\n- ${commit#* }"
              else
                FEATURES="$FEATURES\n- ${commit#* }"
              fi
            elif [[ $commit =~ ^[a-f0-9]+\ fix(\(.+\))?: ]]; then
              FIXES="$FIXES\n- ${commit#* }"
            elif [[ $commit =~ BREAKING\ CHANGE ]]; then
              BREAKING="$BREAKING\n- ${commit#* }"
            else
              OTHER="$OTHER\n- ${commit#* }"
            fi
          done <<< "$COMMITS"
          
          # Build changelog
          CHANGELOG="## What's Changed\n"
          
          if [ -n "$BREAKING" ]; then
            CHANGELOG="$CHANGELOG\n### 💥 Breaking Changes\n$BREAKING\n"
          fi
          
          if [ -n "$FEATURES" ]; then
            CHANGELOG="$CHANGELOG\n### 🚀 Features\n$FEATURES\n"
          fi
          
          if [ -n "$FIXES" ]; then
            CHANGELOG="$CHANGELOG\n### 🐛 Bug Fixes\n$FIXES\n"
          fi
          
          if [ -n "$OTHER" ]; then
            CHANGELOG="$CHANGELOG\n### 📝 Other Changes\n$OTHER\n"
          fi
          
          # Save changelog to file for release notes
          echo -e "$CHANGELOG" > RELEASE_NOTES.md
          
          # Output for GitHub step
          {
            echo 'changelog<<EOF'
            echo -e "$CHANGELOG"
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Commit version changes
        run: |
          git add public/version.json
          git commit -m "chore(release): bump version to ${{ steps.version.outputs.version }}"
          git tag "v${{ steps.version.outputs.version }}"

      - name: Push changes
        run: |
          git push origin main
          git push origin "v${{ steps.version.outputs.version }}"

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "v${{ steps.version.outputs.version }}"
          release_name: "Release v${{ steps.version.outputs.version }}"
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false

      - name: Upload build artifacts to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./dist
          asset_name: build-${{ steps.version.outputs.version }}.zip
          asset_content_type: application/zip
